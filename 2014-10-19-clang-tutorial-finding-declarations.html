<!doctype html><html ng-app=xinhuangGithubCom ng-strict-di><head><meta charset=utf-8><title>> Life is short - Clang Tutorial: Finding Declarations</title><meta name=description content=""><meta name=viewport content="width=device-width"><!-- Place favicon.ico and apple-touch-icon.png in the root directory --><link rel=stylesheet href=styles/vendor-bfbf54ee58.css><link rel=stylesheet href=styles/app-d5a71a58a1.css><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-42274645-1', 'auto');
      ga('send', 'pageview');</script></head><body><!--[if lt IE 10]>
      <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]--><article id=top class=anchor><div layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70><h1 class=md-h1>Clang Tutorial: Finding Declarations</h1><div class=entry-meta>2014-10-19</div><marked>Clang is a very good C/C++ compiler, and it provides great extensibility by its various API to take advantage of it&#039;s syntax parsing, AST construction, semantics analysis, optimization, assembly generation and JIT compilation. Here let&#039;s have some fun playing with Clang and build a Clang tool to list all the declarations in a given file. ## The &quot;Hello World&quot; Program Let&#039;s try to use Clang to write a &quot;Hello World&quot; program: Find all the declarations in a given source file. Given source file below: ``` class MyClass { int foo; public: void bar() {} }; MyClass foobar() { MyClass a; return a; } ``` Run our program to find all declarations: &gt; ./find-decl test.cpp -- &gt; Found MyClass at /home/.../workspace/llvm/debug/Debug+Asserts/bin/find-test.cpp:1:1 &gt; Found MyClass::foo at /home/.../workspace/llvm/debug/Debug+Asserts/bin/find-test.cpp:2:3 &gt; Found MyClass::bar at /home/.../workspace/llvm/debug/Debug+Asserts/bin/find-test.cpp:4:3 &gt; Found foobar at /home/.../workspace/llvm/debug/Debug+Asserts/bin/find-test.cpp:7:1 &gt; Found a at /home/.../workspace/llvm/debug/Debug+Asserts/bin/find-test.cpp:8:3 *Note: Any argument after `--` will be passed to Clang. You can use that to specify arguments like include path `-I/path/to/my/include` or macro definition `-DMY_MACRO`.* Let&#039;s write the program together. ## Building clang First build clang: 1. Get the source code from svn or git repository: git clone http://llvm.org/git/llvm.git src git clone http://llvm.org/git/clang.git src/tools/clang 2. Configure and build using _make_: mkdir debug &amp;&amp; cd debug ../configure # add --enable-optimized --disable-assertions for release build make # this would take quite some time You can also use `make install` to install your built version to the system. ## LibTooling LibTooling is the C++ interface Clang provided. It is very useful when you want to have full control over AST (e.g. static analysis), or to implement a refactoring tool. There are other interfaces like LibClang and Clang Plugins as well. For detailed information you can refer to [Clang Tooling document]. For our &quot;Hello World&quot; program - finding all declarations, using LibTooling is the easiest way. ## The Entry of Everything Let&#039;s start with the main function first: ``` #include &quot;DeclFindingAction.h&quot; #include &quot;clang/Tooling/CommonOptionsParser.h&quot; #include &quot;clang/Tooling/Tooling.h&quot; static llvm::cl::extrahelp CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); llvm::cl::OptionCategory FindDeclCategory(&quot;find-decl options&quot;); static char FindDeclUsage[] = &quot;find-decl &lt;source file&gt;&quot;; int main(int argc, const char **argv) { clang::tooling::CommonOptionsParser option(argc, argv, FindDeclCategory, FindDeclUsage); auto files = option.getSourcePathList(); clang::tooling::ClangTool tool(option.getCompilations(), files); return tool.run(clang::tooling::newFrontendActionFactory&lt;DeclFindingAction&gt;().get()); } ``` This code is quite self-explained. We create an [OptionCategory], use [CommonOptionsParser] to parse command line arguments for us, then feed source files to [ClangTool], and run it with our own _DeclFindingAction_. ## The Compiler Frontend Like most compilers, LLVM is a three-phase compiler. Clang is its C, C++, Objective C and Objective C++ frontend. ![LLVM three-phase structure] _Image from [The Design of LLVM]_ The frontend will parse the source code, check for syntax error and build the abstract syntax tree (AST). Let&#039;s create our own [FrontendAction]: ``` #pragma once #include &quot;DeclFinder.h&quot; #include &quot;clang/Frontend/FrontendAction.h&quot; #include &quot;clang/Frontend/CompilerInstance.h&quot; #include &lt;memory&gt; class DeclFindingAction : public clang::ASTFrontendAction { public: std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(clang::CompilerInstance &amp;CI, clang::StringRef) final { return std::unique_ptr&lt;clang::ASTConsumer&gt;( new DeclFinder(CI.getSourceManager())); } }; ``` Our frontend action will only consume AST and find all declarations, it is inherited from [ASTFrontendAction], and create our own AST consumer via [FrontendAction::CreateASTConsumer]. AST will be consumed by our ASTConsumer - _DeclFinder_. ## AST: Abstract Syntax Tree In Clang, there are two basic types of AST classes: [Decl] and [Stmt], which have many subclasses that covers all the AST nodes we will meet in a source file. For example: * FunctionDecl * TypeDecl * CallExpr ## AST Consumer The [ASTConsumer] will read AST. It provides many interfaces to be overridden when certain type of AST node has been parsed, or after all the translation unit has been parsed. We will override [ASTConsumer::HandleTranslationUnit] to read the AST after we have all the information needed of the file. ``` #pragma once #include &quot;DeclVisitor.h&quot; #include &quot;clang/AST/ASTConsumer.h&quot; #include &quot;clang/AST/ASTContext.h&quot; #include &quot;clang/Basic/SourceManager.h&quot; class DeclFinder : public clang::ASTConsumer { DeclVisitor Visitor; public: DeclFinder(clang::SourceManager &amp;SM) : Visitor(SM) {} void HandleTranslationUnit(clang::ASTContext &amp;Context) final { Visitor.TraverseDecl(Context.getTranslationUnitDecl()); } }; ``` We can process each declaration ([Decl]) in the our [ASTConsumer], but that will require us to identify the actual type of each [Decl] instance: is it a function declaration, a type declaration or a variable declaration? Clang provides us the [RecursiveASTVisitor] to identify the different type of declarations and statements. ## AST Visitor ``` #pragma once #include &quot;clang/AST/RecursiveASTVisitor.h&quot; #include &quot;clang/Basic/SourceManager.h&quot; #include &quot;llvm/Support/raw_ostream.h&quot; #include &lt;string&gt; #include &lt;sstream&gt; class DeclVisitor : public clang::RecursiveASTVisitor&lt;DeclVisitor&gt; { clang::SourceManager &amp;SourceManager; public: DeclVisitor(clang::SourceManager &amp;SourceManager) : SourceManager(SourceManager) {} bool VisitNamedDecl(clang::NamedDecl *NamedDecl) { llvm::outs() &lt;&lt; &quot;Found &quot; &lt;&lt; NamedDecl-&gt;getQualifiedNameAsString() &lt;&lt; &quot; at &quot; &lt;&lt; getDeclLocation(NamedDecl-&gt;getLocStart()) &lt;&lt; &quot;\n&quot;; return true; } private: std::string getDeclLocation(clang::SourceLocation Loc) const { std::ostringstream OSS; OSS &lt;&lt; SourceManager.getFilename(Loc).str() &lt;&lt; &quot;:&quot; &lt;&lt; SourceManager.getSpellingLineNumber(Loc) &lt;&lt; &quot;:&quot; &lt;&lt; SourceManager.getSpellingColumnNumber(Loc); return OSS.str(); } }; ``` This is where the work is done: we overwrite the _RecursiveASTVisitor::VisitNamedDecl_ method to find all the named declaration, print its qualified name and definition location. Above source code introduced the [SourceManager] class. As its name suggested, it manages all the source files. We first get the location of a declaration, then translate it into human readable content. The _llvm::outs()_ is similiar to the _std::cout_, but it&#039;s suggested to use _llvm::outs()_ instead of _std::cout_ according to the [LLVM Coding Standard]. ## Put It All Together Here is our makefile: ``` CLANG_LEVEL := ../../.. TOOLNAME = find-decl include $(CLANG_LEVEL)/../../Makefile.config LINK_COMPONENTS := $(TARGETS_TO_BUILD) asmparser bitreader support mc option USEDLIBS = clangTooling.a clangFrontend.a clangSerialization.a clangDriver.a \ clangRewriteFrontend.a clangRewrite.a \ clangParse.a clangSema.a clangAnalysis.a \ clangAST.a clangASTMatchers.a clangEdit.a clangLex.a clangBasic.a include $(CLANG_LEVEL)/Makefile ``` All the source code above should be put under _${llvm_src}/tools/clang/tools/clang-playground/find-decl/_. And put another makefile in _${llvm_src}/tools/clang/tools/clang-playground/_: ``` CLANG_LEVEL := ../.. include $(CLANG_LEVEL)/../../Makefile.config PARALLEL_DIRS := find-decl DIRS := include $(CLANG_LEVEL)/Makefile ``` Edit _Makefile_ in _${llvm_src}/tools/clang/tools/_, add _clang-playground_ to _OPTIONAL\_PARALLEL\_DIRS_ so Clang makefile can find our project. Now you should be able to build our project along with Clang. The built out binary should be located in _debug/Debug+Asserts/bin/_. ## The Glitch Wait! When there is a `#include &lt;vector&gt;` in the source file, our _find-decl_ will print out all the declarations in that included file, because these included files are parsed and consumed as a whole with our source file. To fix this, we need to check if the declarations are defined in our source file: ``` void HandleTranslationUnit(clang::ASTContext &amp;Context) final { auto Decls = Context.getTranslationUnitDecl()-&gt;decls(); for (auto &amp;Decl : Decls) { const auto&amp; FileID = SourceManager.getFileID(Decl-&gt;getLocation()); if (FileID != SourceManager.getMainFileID()) continue; Visitor.TraverseDecl(Decl); } } ``` This is the improved logic. We find out the file ID of each declaration belongs to, compare it with the _main file ID_. If they are equal, that means it&#039;s defined in our source file. _All the source code can be found at [clang-playground]._ [LLVM three-phase structure]:/latfig1.gif [Clang Tooling document]:http://clang.llvm.org/docs/Tooling.html [FrontendAction]:http://clang.llvm.org/doxygen/classclang_1_1FrontendAction.html [ASTConsumer]:http://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html [Decl]:http://clang.llvm.org/doxygen/classclang_1_1Decl.html [RecursiveASTVisitor]:http://clang.llvm.org/doxygen/classclang_1_1RecursiveASTVisitor.html [ClangTool]:http://clang.llvm.org/doxygen/classclang_1_1tooling_1_1ClangTool.html [CommonOptionsParser]:http://clang.llvm.org/doxygen/classclang_1_1tooling_1_1CommonOptionsParser.html [OptionCategory]:http://llvm.org/docs/doxygen/html/classllvm_1_1cl_1_1OptionCategory.html [The Design of LLVM]:http://www.drdobbs.com/architecture-and-design/the-design-of-llvm/240001128?pgno=1 [FrontendAction::CreateASTConsumer]:http://clang.llvm.org/doxygen/classclang_1_1FrontendAction.html#a9277d23d8eec19dad5a9aeef721cd6a3 [ASTFrontendAction]:http://clang.llvm.org/doxygen/classclang_1_1ASTFrontendAction.html [Stmt]:http://clang.llvm.org/doxygen/classclang_1_1Stmt.html [ASTConsumer::HandleTranslationUnit]:http://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html#a2bea2db1d0e8af16c60ee7847f0d46ff [SourceManager]:http://clang.llvm.org/doxygen/classclang_1_1SourceManager.html [LLVM Coding Standard]:http://llvm.org/docs/CodingStandards.html [SourceLocation]:http://clang.llvm.org/doxygen/classclang_1_1SourceLocation.html [clang-playground]:https://github.com/xinhuang/clang-playground.git</marked></div></div><md-divider></md-divider><div class=footer layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70 layout=row><a href=/ >Home</a><div flex></div><a href="" ng-click=blog.scrollToTop()>Top</a></div></div></article><script src=scripts/vendor-b1387507a1.js></script><script src=scripts/app-1e997bf866.js></script></body></html>