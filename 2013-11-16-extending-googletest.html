<!doctype html><html ng-app=xinhuangGithubCom ng-strict-di><head><meta charset=utf-8><title>Extending GoogleTest</title><meta name=description content=""><meta name=viewport content="width=device-width"><!-- Place favicon.ico and apple-touch-icon.png in the root directory --><link rel=stylesheet href=styles/vendor-742ba0962d.css><link rel=stylesheet href=styles/app-d5a71a58a1.css><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-42274645-1', 'auto');
      ga('send', 'pageview');</script></head><body><!--[if lt IE 10]>
      <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]--><article id=top class=anchor><div layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70><h1 class=md-h1>Extending GoogleTest</h1><div class=entry-meta>2013-11-16</div>
            <marked>
                
Maybe you are tired of the syntax [googletest] has chosen, so you deside to invent you own unit test DSL. But re-implementing the whole execution &amp; report part of a unit test framework would be too much, esp. you want to ship your &quot;product&quot; somewhere.

Then the option left would be extending an existing one, and [googletest] is a good candidate.

## Behind the curtain

### A basic version

First of all, before extending googletest, we need to know what&#039;s behind the curtain.  
A typical unit test would be:

    class Fixture : public ::testing::Test {
    };

    TEST_F(Fixture, GIVEN_1_THEN_add_1_SHOULD_return_0) {
        ASSERT_EQ(0, 1 + 1);
    }

_Sorry for my bad math._

In above code snippet, googletest does 3 things:  
1. Create a class inherited from `Fixture`.  
2. Override a method in `Fixture`.  
3. Execute some code to register the newly created class somewhere.

All the magic is done within macro `TEST_F`.  
If you are familiar with macro, it won&#039;t take a minute to figure out `TEST_F` actually expand to:  

    / --------- Expand start -----------&gt; /
    class prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix {
        void SomeMethodCalledWhenExecuteTest();
    };
    void prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix::SomeMethodCalledWhenExecuteTest()
    / &lt;-------- Expand end -------------- /
    {
        ASSERT_EQ(0, 1 + 1);
    }

Now, we&#039;ve done No. 1 and No. 2. But what about No. 3? How to execute some code outside the `main` function?  
The answer is simple: _Use global variables_, and perform registration in the construction of the variable:

    / --------- Expand start -----------&gt; /
    class prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix {
        void SomeMethodCalledWhenExecuteTest();
    };
    prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix instance_GIVEN_1_THEN_add_1_SHOULD_return_0;
    void prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix::SomeMethodCalledWhenExecuteTest()
    / &lt;-------- Expand end -------------- /

### The googletest version

This only demonstrate the basic idea of how `TEST_F` works. Knowing this, we can find out how to extend googletest.

Watching the macro _TEST\_F_, it does a bit more than our basic version:

    #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\
    class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
     public:\
      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
     private:\
      virtual void TestBody();\
      static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
      GTEST_DISALLOW_COPY_AND_ASSIGN_(\
          GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
    };\

Above code defines the test class inherites from test fixture.

First, create the global variable:

    ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\
      ::test_info_ =\

Then, initialize the global variable:

        ::testing::internal::MakeAndRegisterTestInfo(\
            #test_case_name, #test_name, NULL, NULL, \
            (parent_id), \
            parent_class::SetUpTestCase, \
            parent_class::TearDownTestCase, \
            new ::testing::internal::TestFactoryImpl&lt;\
                GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);\

Registration is performed inside `::testing::internal::MakeAndRegisterTestInfo`.

At last, is the _TestBody_ stub, which connects real test code:

    void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()

#### Inside RegisterTestInfo

Let&#039;s take a closer look at what happened inside `MakeAndRegisterTestInfo`:

    TestInfo* MakeAndRegisterTestInfo(
        const char* test_case_name,
        const char* name,
        const char* type_param,
        const char* value_param,
        TypeId fixture_class_id,
        SetUpTestCaseFunc set_up_tc,                // Set up for the first of fixture class.
        TearDownTestCaseFunc tear_down_tc,          // Tear down after execute of all tests in a fixture.
        TestFactoryBase* factory);                  // Factory creates the test class instances.

First 2 parameters are easy to tell from their name, last 3 are also not difficult.  
`type_param` and `value_param` are both passed as `NULL` in `TEST_F` macro, so we can ignore them until we really got some problem.

Then, what is `fixture_class_id`? If we are using a different model from googletest, what should the value be?   
By searching the code, we can easily find out the type id is used to tell a test going to run whether is the first one under a fixture. If it is, then the `tear_down_tc` of previous fixture and `set_up_tc` of the fixture should be called.  
So if you don&#039;t care about it, ignore it.

## Register our test

After all the work, it is clear that all the macro makes googletest &quot;user interface&quot;. If we want to connect our unit test DSL with googletest, register the test via `MakeAndRegisterTestInfo`.

Now we are ready to let our test sneaks in. Here is the complete code: (C++ 11)

    class NoFixture {};
    void nop() {}

    class FunctionTest : public ::testing::Test {
    public:
        FunctionTest(function&lt;void()&gt; function)
            : function_(function)
        {}
    private:
        const function&lt;void()&gt; function_;
        void TestBody() override { function_(); }
    };

    class TestFactory : public ::testing::internal::TestFactoryBase {
    public:
        TestFactory(function&lt;void()&gt; function)
            : function_(function) {}
        ::testing::Test* CreateTest() override {
            return new FunctionTest(function_);
        }
    private:
        const function&lt;void()&gt; function_;
    };

    void Register(const string&amp; test_name, const string&amp; case_name, function&lt;void()&gt; test) {
        static auto fixture_class_id = ::testing::internal::GetTypeId&lt;NoFixture&gt;();
        ::testing::internal::MakeAndRegisterTestInfo(test_name.c_str(), case_name.c_str(), nullptr, nullptr,
            fixture_class_id, nop, nop, new TestFactory(test));
    }

[googletest]: https://code.google.com/p/googletest/

            </marked>
            </div></div><md-divider></md-divider><div class=footer layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70 layout=row><a href=/ >Home</a><div flex></div><a href=#>Top</a></div></div></article><script src=scripts/vendor-992057851c.js></script><script src=scripts/app-2f307186b4.js></script></body></html>