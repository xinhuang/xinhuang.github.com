<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1"><title>Clang Tutorial: The AST Matcher</title></head><body><article id=top class=markdown-body><div layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70><h1>Clang Tutorial: The AST Matcher</h1><div class=metadata></div><hr>
                <p>In <a href="http://xinhuang.github.io/clang/2014/10/19/clang-tutorial-finding-declarations">previous post</a> we have learned about Clang abstract syntax tree (AST) and made a simple Clang tool that will print all the
declarations in a given source file. Now Let&#39;s play with Clang AST matchers and make another tool to
detect when a <em>std::vector</em> is passed by value - which usually causes a
performance hit.</p>
<h2 id="the-pass-by-value-std-vector-finding-program">The Pass-by-Value std::vector Finding Program</h2>
<p>The example.cpp:</p>
<pre class="hljs"><code class="C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; is)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; is)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foobar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cis)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fooboo</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cis)</span></span>;</code></pre><p>Let&#39;s feed it to our <em>find-vec</em> program:</p>
<blockquote>
<p>$ ./find-vec example.cpp -- -std=c++11<br>example.cpp:5:6<br>example.cpp:6:6  </p>
</blockquote>
<p><em>Here we told Clang parser to use C++ 11 syntax by passing <code>-std=c++11</code> after <code>--</code>.</em></p>
<h2 id="the-clang-ast">The Clang AST</h2>
<p>If you still remember the <em>Decl</em> and <em>Stmt</em>, these are the AST nodes that we will come
across when processing a source file. With different <em>Decl</em>, <em>Stmt</em> and their derived
classes like <em>NamedDecl</em> and <em>CallExpr</em>, we can obtain lots of information like
variable type, name, definition information, etc.</p>
<p>To examine all the function declarations with any parameter of type <em>std::vector</em>,
we will need to match specific AST node that is:</p>
<ul>
<li>Function declaration or definition</li>
<li>Has at least one parameter of type <em>std::vector</em></li>
</ul>
<p>Clang provides us a domain specific language (DSL) to create predicates on Clang&#39;s AST.
It is written in and can be used from C++, allowing us to match AST nodes and
extract its attributes.</p>
<h2 id="the-ast-matcher">The AST Matcher</h2>
<p>To use the AST matchers, we need to do is to call a bunch of matcher creation
function, chain them together to compose the matcher we need, and/or bind the target
node with a name so we can extract it later.</p>
<p>To match a function declaration:</p>
<pre class="hljs"><code class="C++">DeclarationMatcher Matcher = functionDecl();</code></pre><p>Then let&#39;s match its parameter:</p>
<pre class="hljs"><code class="C++">DeclarationMatcher Matcher = functionDecl(hasAnyParameter(...));</code></pre><p>To matcher a parameter, we can use <em>hasParameter(N, ParamMatcher)</em>, which will match
 the N&#39;th of parameter with given parameter matcher. Here we will need to match any
 parameter that of type <em>std::vector</em>, so we will use <em>hasAnyParameter</em>.</p>
<p>Next match the parameter type:</p>
<pre class="hljs"><code class="C++">DeclarationMatcher Matcher = functionDecl(
  hasAnyParameter(hasType(recordDecl(matchesName(<span class="hljs-string">"std::vector"</span>))));</code></pre><h2 id="the-matchcallback">The MatchCallback</h2>
<p>When the AST matcher find the right node, the corresponding
<code>clang::ast_matchers::MatchFinder::MatchCallback</code> will be invoked with matched result. By providing a <code>MatchCallback</code>, we can print the function declarations/definitions that accept any parameter of type <code>std::vector</code> that is passed by value.</p>
<pre class="hljs"><code class="C++"><span class="hljs-keyword">class</span> VecCallback : <span class="hljs-keyword">public</span> clang::ast_matchers::MatchFinder::MatchCallback {
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span>
  <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::ast_matchers::MatchFinder::MatchResult &amp;Result)</span> final </span>{
    llvm::outs() &lt;&lt; <span class="hljs-string">"."</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *F =
            Result.Nodes.getDeclAs&lt;clang::FunctionDecl&gt;(FunctionID)) {
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; SM = *Result.SourceManager;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; Loc = F-&gt;getLocation();
      llvm::outs() &lt;&lt; SM.getFilename(Loc) &lt;&lt; <span class="hljs-string">":"</span>
                   &lt;&lt; SM.getSpellingLineNumber(Loc) &lt;&lt; <span class="hljs-string">":"</span>
                   &lt;&lt; SM.getSpellingColumnNumber(Loc) &lt;&lt; <span class="hljs-string">"\n"</span>;
    }
  }
};</code></pre><h2 id="references">References</h2>
<p>Clang also provides a simple document of AST matchers: <a href="http://clang.llvm.org/docs/LibASTMatchers.html">Matching the Clang AST</a>.
For a complete reference of AST matchers, you can find it in <a href="http://clang.llvm.org/docs/LibASTMatchersReference.html">AST Matcher Reference</a>.</p>
<p><em>All the source code in this post can be found at <a href="https://github.com/xinhuang/clang-playground.git">clang-playground</a>.</em></p>

                </div></div><hr><a href=/ class=left>Home</a> <a href=# class=right>Top</a></article><style>body{margin:1em auto;max-width:40em;padding:0 .62em;font:1.2em/1.62em sans-serif;background-color:#f0efd1}h1,h2,h3{line-height:1.2em}@media print{body{max-width:none}}a{text-decoration:none}article{margin:auto;font-size:14px;padding:3px 1em}.metadata{color:rgba(0,0,0,.54)}hr{display:block;height:1px;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}.left{float:left}.right{float:right}</style><link rel=stylesheet href=/github-markdown.css><link rel=stylesheet href=/zenburn.css></body><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-42274645-1","auto"),ga("send","pageview")</script></html>