<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1"><title>Detect Race Condition Using Clang Thread Sanitizer</title></head><body><article id=top class=markdown-body><div layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70><h1>Detect Race Condition Using Clang Thread Sanitizer</h1><div class=metadata></div><hr>
                <p>To find out where a race condition happens is a big headache, usually it requires good understanding of the program and days of debugging.
<a href="https://urldefense.proofpoint.com/v1/url?u=https://code.google.com/p/thread-sanitizer/&amp;k=Bmn%2BpBF6%2FxX%2F6xeXViRpFg%3D%3D%0A&amp;r=XKHKqvEQZPfF56uL%2BOZCgw%3D%3D%0A&amp;m=3U5%2BNCJxni%2FCWwoCYzx0v5Pk0RDV8dSjM7rlg2QbtHg%3D%0A&amp;s=0dc51daf68f724ca5ebe3a77b42dcce4bcb1742018cf258627b113c92d3aa113">ThreadSanitizer</a>, one of the many sanitizers shipped with Clang, can be a useful tool to help us find out where the race condition is happening.</p>
<p>Here is a very simple program:</p>
<pre><code>#include &lt;thread&gt;

using namespace std;

int flag = 0;

int main() {

  auto t1 = thread([&amp;]() {
    flag = 1;
  });
  auto t2 = thread([&amp;]() {
    flag = 2;
  });

  t1.join();
  t2.join();

  return 0;
}
</code></pre><p>In above code example, we created 2 threads: thread <code>t1</code> will set global variable <code>flag</code> to <code>1</code>; thread <code>t2</code> will set <code>flag</code> to <code>2</code>.</p>
<p>Let&#39;s compile and run it.</p>
<pre><code>$ clang++ -std=c++11 -pthread -g write_race.cpp $ ./a.out
t2 finished
t1 finished
</code></pre><p>It runs without an error. But there is a potential race condition because the <code>flag</code> is not guarded by any synchronization method. Let&#39;s run it using ThreadSanitizer again:</p>
<pre><code>$ clang++ -std=c++11 -pthread -g write_race.cpp -fsanitize=thread $ ./a.out ==================
WARNING: ThreadSanitizer: data race (pid=3631)
  Write of size 4 at 0x7fdc8845f2f4 by thread T2:
    #0 operator() .../write_race.cpp:13 (a.out+0x0000000a66e6)
    #1 void std::_Bind_simple&lt;main::$_1
()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;)
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1731
(a.out+0x0000000a6630)
    #2 std::_Bind_simple&lt;main::$_1 ()&gt;::operator()()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1720
(a.out+0x0000000a65d0)
    #3 std::thread::_Impl&lt;std::_Bind_simple&lt;main::$_1 ()&gt; &gt;::_M_run()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/thread:115
(a.out+0x0000000a6579)
    #4 std::this_thread::__sleep_for(std::chrono::duration&lt;long,
std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l,
1000000000l&gt; &gt;) &lt;null&gt;:0 (libstdc++.so.6+0x0000000b176f)

  Previous write of size 4 at 0x7fdc8845f2f4 by thread T1:
    #0 operator() write_race.cpp:10 (a.out+0x0000000a9156)
    #1 void std::_Bind_simple&lt;main::$_0
()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;)
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1731
(a.out+0x0000000a90a0)
    #2 std::_Bind_simple&lt;main::$_0 ()&gt;::operator()()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1720
(a.out+0x0000000a9040)
    #3 std::thread::_Impl&lt;std::_Bind_simple&lt;main::$_0 ()&gt; &gt;::_M_run()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/thread:115
(a.out+0x0000000a8fe9)
    #4 std::this_thread::__sleep_for(std::chrono::duration&lt;long,
std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l,
1000000000l&gt; &gt;) &lt;null&gt;:0 (libstdc++.so.6+0x0000000b176f)

  Location is global &#39;&lt;null&gt;&#39; of size 0 at 0x000000000000 (a.out+0x0000011092f4)

...

SUMMARY: ThreadSanitizer: data race write_race.cpp:13 operator() ==================
ThreadSanitizer: reported 1 warnings
</code></pre><p>Data race on global <code>flag</code> is caught by thread sanitizer, and it happens at <code>write_race.cpp:13</code> and <code>write_race.cpp:10</code>.</p>
<p>This is a quite dumb program. Let&#39;s have take another example:</p>
<pre><code>#include &lt;thread&gt;
#include &lt;iostream&gt;

using namespace std;

struct A {
  virtual void foo() {}
};

int main(int argc, char const *argv[])
{
  auto *a = new A();
  cout &lt;&lt; &quot;a = &quot;a &lt;&lt; endl;
  auto t1 = thread([=](){ a-&gt;foo(); });
  auto t2 = thread([=](){ delete a; });
  t1.join();
  t2.join();
  return 0;
}
</code></pre><p>Compile and run:</p>
<pre><code>$ clang++ -std=c++11 -pthread -g race_2.cpp
$ ./a.out
$ ./a.out Segmentation fault (core dumped)
</code></pre><p>The first execution is ok, but the second execution yields an segmentation fault, because we called the virtual function <code>A::foo()</code> after the instance has been destructed in thread <code>t2</code>.</p>
<p>Seems this is a pretty random data race. Let&#39;s run it using ThreadSanitizer see if it can be caught:</p>
<pre><code>$ clang++ -std=c++11 -pthread -g race_2.cpp -fsanitize=thread $ ./a.out a = 0x7d040000f7f0 ==================
WARNING: ThreadSanitizer: data race (pid=4106)
  Write of size 8 at 0x7d040000f7f0 by thread T2:
    #0 operator delete(void*) &lt;null&gt;:0 (a.out+0x0000000488eb)
    #1 operator() race_2.cpp:15 (a.out+0x0000000a6cbb)
    #2 void std::_Bind_simple&lt;main::$_1
()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;)
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1731
(a.out+0x0000000a6be0)
    #3 std::_Bind_simple&lt;main::$_1 ()&gt;::operator()()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1720
(a.out+0x0000000a6b80)
    #4 std::thread::_Impl&lt;std::_Bind_simple&lt;main::$_1 ()&gt; &gt;::_M_run()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/thread:115
(a.out+0x0000000a6b29)
    #5 std::this_thread::__sleep_for(std::chrono::duration&lt;long,
std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l,
1000000000l&gt; &gt;) &lt;null&gt;:0 (libstdc++.so.6+0x0000000b176f)

  Previous read of size 8 at 0x7d040000f7f0 by thread T1:
    #0 operator() race_2.cpp:14 (a.out+0x0000000a977d)
    #1 void std::_Bind_simple&lt;main::$_0
()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;)
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1731
(a.out+0x0000000a96b0)
    #2 std::_Bind_simple&lt;main::$_0 ()&gt;::operator()()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:1720
(a.out+0x0000000a9650)
    #3 std::thread::_Impl&lt;std::_Bind_simple&lt;main::$_0 ()&gt; &gt;::_M_run()
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/thread:115
(a.out+0x0000000a95f9)
    #4 std::this_thread::__sleep_for(std::chrono::duration&lt;long,
std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l,
1000000000l&gt; &gt;) &lt;null&gt;:0 (libstdc++.so.6+0x0000000b176f)

  Location is heap block of size 8 at 0x7d040000f7f0 allocated by main thread:
    #0 operator new(unsigned long) &lt;null&gt;:0 (a.out+0x00000004837d)
    #1 main race_2.cpp:12 (a.out+0x0000000a3e50)

  Thread T2 (tid=4110, running) created by main thread at:
    #0 pthread_create &lt;null&gt;:0 (a.out+0x00000004b831)
    #1 std::thread::_M_start_thread(std::shared_ptr&lt;std::thread::_Impl_base&gt;)
&lt;null&gt;:0 (libstdc++.so.6+0x0000000b19be)
    #2 main race_2.cpp:15 (a.out+0x0000000a3f4e)

  Thread T1 (tid=4109, running) created by main thread at:
    #0 pthread_create &lt;null&gt;:0 (a.out+0x00000004b831)
    #1 std::thread::_M_start_thread(std::shared_ptr&lt;std::thread::_Impl_base&gt;)
&lt;null&gt;:0 (libstdc++.so.6+0x0000000b19be)
    #2 main race_2.cpp:14 (a.out+0x0000000a3f0c)

SUMMARY: ThreadSanitizer: data race ??:0 operator delete(void*) ==================
ThreadSanitizer: reported 1 warnings
</code></pre><p>The report shows that we are contention at <code>0x7d040000f7f0</code> of size 8 by thread T1 &amp; T2. And the source line is <code>race_2.cpp:12</code> and <code>race_2.cpp:13</code>. Pretty smart! That&#39;s where we invoke the virtual function <code>A::foo()</code> and delete the pointer of A.</p>
<p>One of the good things is the Sanitizer doesn&#39;t require runing the program many times to find the bug.</p>
<p>Another good thing is the Sanitizer can tell us exactly where the race condition happens. But how can we find out the reason?</p>
<p>From the program output, we know <code>0x7d040000f7f0</code> is the address of the memory block <code>new A()</code> returned, and contention happens at first 8 bytes. On a x64 machine, that is the location of vptr. In the destruction of class A, vptr will be overwritten to some other value, which probably gives a message &quot;pure virtual function call&quot; when invoke, to prevent the virtual function to be called after destruction; but during the invocation of <code>A::foo()</code>, we need to read the value of vptr to find the function address. When the write and read happens at the same time, there is the race condition.</p>
<p>The <a href="https://urldefense.proofpoint.com/v1/url?u=https://code.google.com/p/thread-sanitizer/&amp;k=Bmn%2BpBF6%2FxX%2F6xeXViRpFg%3D%3D%0A&amp;r=XKHKqvEQZPfF56uL%2BOZCgw%3D%3D%0A&amp;m=3U5%2BNCJxni%2FCWwoCYzx0v5Pk0RDV8dSjM7rlg2QbtHg%3D%0A&amp;s=0dc51daf68f724ca5ebe3a77b42dcce4bcb1742018cf258627b113c92d3aa113">ThreadSanitizer</a> is a very powerful tool to help detect race condition. The <a href="https://code.google.com/p/thread-sanitizer/wiki/CppManual">ThreadSanitizer manual</a> contains all of the information necessary to start. It is easy to use and can be integrated with any build system using GCC or LLVM: one extra compile-time option and run the program after to see the errors. Unlike other tools, it understands compiler-builtin atomics and synchronization, therefore provides very accurate results. More information on how <a href="https://urldefense.proofpoint.com/v1/url?u=https://code.google.com/p/thread-sanitizer/&amp;k=Bmn%2BpBF6%2FxX%2F6xeXViRpFg%3D%3D%0A&amp;r=XKHKqvEQZPfF56uL%2BOZCgw%3D%3D%0A&amp;m=3U5%2BNCJxni%2FCWwoCYzx0v5Pk0RDV8dSjM7rlg2QbtHg%3D%0A&amp;s=0dc51daf68f724ca5ebe3a77b42dcce4bcb1742018cf258627b113c92d3aa113">ThreadSanitizer</a> works can be found on <a href="https://code.google.com/p/thread-sanitizer/wiki/Algorithm">the ThreadSanitizer wiki</a>.</p>
<p><em>Reference</em></p>
<p>2nd program example comes from GoingNative 2013 <a href="https://urldefense.proofpoint.com/v1/url?u=http://channel9.msdn.com/Events/GoingNative/2013/The-Care-and-Feeding-of-C-s-Dragons&amp;k=Bmn%2BpBF6%2FxX%2F6xeXViRpFg%3D%3D%0A&amp;r=XKHKqvEQZPfF56uL%2BOZCgw%3D%3D%0A&amp;m=3U5%2BNCJxni%2FCWwoCYzx0v5Pk0RDV8dSjM7rlg2QbtHg%3D%0A&amp;s=ff921eae48afb6b89d67803853eb508c06e9726ab41c5c8c8d4cbaf731429a6e">The Care and Feeding of C++&#39;s Dragons</a></p>
<p><em>This article is for Sep. 2014 newsletter of SWDEV Sig Schlumberger.</em></p>

                </div></div><hr><a href=/ class=left>Home</a> <a href=# class=right>Top</a></article><style>body{margin:1em auto;max-width:40em;padding:0 .62em;font:1.2em/1.62em sans-serif;background-color:#f0efd1}h1,h2,h3{line-height:1.2em}@media print{body{max-width:none}}a{text-decoration:none}article{margin:auto;font-size:14px;padding:3px 1em}.metadata{color:rgba(0,0,0,.54)}hr{display:block;height:1px;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}.left{float:left}.right{float:right}</style><link rel=stylesheet href=/github-markdown.css></body><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-42274645-1","auto"),ga("send","pageview")</script></html>