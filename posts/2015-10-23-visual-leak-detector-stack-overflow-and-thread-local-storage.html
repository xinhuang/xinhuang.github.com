<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1"><title>Visual Leak Detector Stack Overflow And Thread Local Storage</title></head><body><article id=top class=markdown-body><div><div><h1>Visual Leak Detector Stack Overflow And Thread Local Storage</h1><div class=metadata>2015-10-23</div><hr>
                <h2 id="abstract">Abstract</h2>
<p>On Windows, by default Thread Local Storage (TLS) has 0x40 slots. Later it is expanded
by 0x400 more slots. These expansion slots are created on demand when TLS APIs
<code>TlsAlloc/TlsFree/TlsGetValue/TlsSetValue</code> are invoked in current thread. And the expansion is achieved by
calling Windows API <code>RtlAllocateHeap</code>. When TLS APIs are invoked the first time with
slot number &gt;= 0x40 in a thread which hasn&#39;t expand before, TLS expansion will be triggered.</p>
<p>Visual Leak Detector (VLD) is a memory allocation tracing library, assisting troubleshooting
memory leak issues by hooking memory allocation APIs, including <code>RtlAllocateHeap</code>.</p>
<p>When a memory allocation happens, VLD will store the information in its TLS slot to
avoid contention and reduce performance impact. When VLD is assigned with a TLS slot &gt;= 0x40
and a memory allocation happens in a thread that hasn&#39;t expand TLS, the access to TLS slot
from VLD will trigger another TLS expansion.</p>
<p>However, the expansion will call <code>RtlAllocateHeap</code> to allocate memory and the record of
this memory allocation will be saved into TLS slot by VLD, which will again trigger another
TLS expansion... In this way, The program will enter infinite recursion.</p>
<h2 id="analysis">Analysis</h2>
<p>Today I meet a crash because of infinite recursion with call stacks switching between KernelBase.dll and VLD.dll.
It appears to be somehow VLD enters an infinite recursion when calling <code>VisualLeakDetector::getTls()</code>.
What&#39;s more interesting is despite the fact that this crash is repeatable, VLD has been enabled in our product for long.</p>
<p>Why it happens now?</p>
<p>The call stack looks like below:</p>
<pre class="hljs"><code class="undefined">...
6dc9 0759f314 09ddbfcc 00000042 0a16b870 09defbd0 KERNELBASE!TlsSetValue+0x4f
6dca 0759f360 09ddc1a3 09defbd0 00490000 0759f38c vld!VisualLeakDetector::getTls+0xfc [c:\build\vld\v24c\src\vld.cpp @ 1075]
6dcb 0759f370 09dda74b 0baa5930 00000008 0759f69c vld!VisualLeakDetector::enabled+0x23 [c:\build\vld\v24c\src\vld.cpp @ 982]
6dcc 0759f38c 75c445cf 00490000 00000008 00001000 vld!VisualLeakDetector::_HeapAlloc+0x2b [c:\build\vld\v24c\src\vld_hooks.cpp @ 1617]
6dcd 0759f3a8 09ddbfcc 00000042 0a16b870 09defbd0 KERNELBASE!TlsSetValue+0x4f
6dce 0759f3f4 09ddc1a3 09defbd0 05480fe8 0759f420 vld!VisualLeakDetector::getTls+0xfc [c:\build\vld\v24c\src\vld.cpp @ 1075]
6dcf 0759f404 09dda74b 05480fd0 0000004c 0759f45c vld!VisualLeakDetector::enabled+0x23 [c:\build\vld\v24c\src\vld.cpp @ 982]
6dd0 0759f420 7614ea43 00490000 00000000 00000018 vld!VisualLeakDetector::_HeapAlloc+0x2b [c:\build\vld\v24c\src\vld_hooks.cpp @ 1617]
6dd1 0759f434 7614ea5f 762466bc 00000018 0759f450 ole32!CRetailMalloc_Alloc+0x16 [d:\w7rtm\com\ole32\com\class\memapi.cxx @ 641]
...
6dec 0759fde0 77419882 0546b610 718c8e2a 00000000 kernel32!BaseThreadInitThunk+0xe
6ded 0759fe20 77419855 7612d854 0546b610 00000000 ntdll!__RtlUserThreadStart+0x70
6dee 0759fe38 00000000 7612d854 0546b610 00000000 ntdll!_RtlUserThreadStart+0x1b</code></pre><p>When a thread starts and tries to allocate memory, VLD will trace all memory
allocations. VLD records allocation information in a TLS slot to avoid
contention and reduce performance impact. When VLD tries to
initialize the TLS slot, Windows API <code>TlsSetValue</code> allocates memory,
and VLD traces the allocation by saving it into TLS. This is
what we can guess from the crash dump.</p>
<p>But why <code>TlsSetValue</code> will allocate memory? Let&#39;s take a look at the disassembled code:<br>(uninteresting details are omited, indentations are added for better formating and understanding)</p>
<pre class="hljs"><code class="x86asm">KERNELBASE!TlsSetValue:
// BOOL WINAPI TlsSetValue(_In_ <span class="hljs-built_in">DWORD</span> dwTlsIndex, _In_opt_ LPVOID lpTlsValue)
...
75c44585 <span class="hljs-number">56</span>              <span class="hljs-keyword">push</span>    <span class="hljs-built_in">esi</span>
75c44586 648b3518000000  <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">fs</span>:[<span class="hljs-number">18h</span>]
// <span class="hljs-built_in">ESI</span> points to Thread Environment Block (TEB)
75c4458d <span class="hljs-number">57</span>              <span class="hljs-keyword">push</span>    <span class="hljs-built_in">edi</span>
75c4458e 8b7d08          <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]
75c44591 83ff40          <span class="hljs-keyword">cmp</span>     <span class="hljs-built_in">edi</span>,<span class="hljs-number">40h</span>
75c44594 <span class="hljs-number">7260</span>            <span class="hljs-keyword">jb</span>      KERNELBASE!TlsSetValue+<span class="hljs-number">0x76</span> (75c445f6)  Branch

// if (dwTlsIndex &gt;= <span class="hljs-number">0x40</span>) {

  KERNELBASE!TlsSetValue+<span class="hljs-number">0x16</span>:
  75c44596 83ef40          <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">edi</span>,<span class="hljs-number">40h</span>
  75c44599 81ff00040000    <span class="hljs-keyword">cmp</span>     <span class="hljs-built_in">edi</span>,<span class="hljs-number">400h</span>
  75c4459f 734e            <span class="hljs-keyword">jae</span>     KERNELBASE!TlsSetValue+<span class="hljs-number">0x6f</span> (75c445ef)  Branch

  // if (dwTlsIndex &lt; <span class="hljs-number">0x440</span>) {

    KERNELBASE!TlsSetValue+<span class="hljs-number">0x21</span>:
    75c445a1 8b86940f0000    <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">esi</span>+<span class="hljs-number">0F94h</span>]
    75c445a7 85c0            <span class="hljs-keyword">test</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>
    75c445a9 753c            <span class="hljs-keyword">jne</span>     KERNELBASE!TlsSetValue+<span class="hljs-number">0x67</span> (75c445e7)  Branch

    // if (pTeb-&gt;TlsExpansionSlots == NULL)

      KERNELBASE!TlsSetValue+<span class="hljs-number">0x2b</span>:
      75c445ab e88126ffff      <span class="hljs-keyword">call</span>    KERNELBASE!KernelBaseGetGlobalData (75c36c31)
      75c445b0 8b402c          <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">eax</span>+<span class="hljs-number">2Ch</span>]
      75c445b3 648b0d18000000  <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">fs</span>:[<span class="hljs-number">18h</span>]
      75c445ba <span class="hljs-number">6800100000</span>      <span class="hljs-keyword">push</span>    <span class="hljs-number">1000h</span>
      75c445bf 83c808          <span class="hljs-keyword">or</span>      <span class="hljs-built_in">eax</span>,<span class="hljs-number">8</span>
      75c445c2 <span class="hljs-number">50</span>              <span class="hljs-keyword">push</span>    <span class="hljs-built_in">eax</span>
      75c445c3 8b4130          <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ecx</span>+<span class="hljs-number">30h</span>]
      75c445c6 ff7018          <span class="hljs-keyword">push</span>    <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">eax</span>+<span class="hljs-number">18h</span>]
      75c445c9 ff151810c375    <span class="hljs-keyword">call</span>    <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [KERNELBASE!_imp__RtlAllocateHeap (75c31018)]
      75c445cf 85c0            <span class="hljs-keyword">test</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>
      75c445d1 750e            <span class="hljs-keyword">jne</span>     KERNELBASE!TlsSetValue+<span class="hljs-number">0x61</span> (75c445e1)  Branch
      ...
      KERNELBASE!TlsSetValue+<span class="hljs-number">0x61</span>:
      75c445e1 8986940f0000    <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">esi</span>+<span class="hljs-number">0F94h</span>],<span class="hljs-built_in">eax</span>

      // pTeb-&gt;TlsExpansionSlots = RtlAllocateHeap(...)

    KERNELBASE!TlsSetValue+<span class="hljs-number">0x67</span>:
    75c445e7 8b4d0c          <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]
    75c445ea 890cb8          <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">eax</span>+<span class="hljs-built_in">edi</span>*<span class="hljs-number">4</span>],<span class="hljs-built_in">ecx</span>
    75c445ed eb11            <span class="hljs-keyword">jmp</span>     KERNELBASE!TlsSetValue+<span class="hljs-number">0x80</span> (75c44600)  Branch

    // Set value to TLS slot
  }  else { // ERROR if (dwTlsIndex &gt;= <span class="hljs-number">0x440</span>) }
} // if (dwTlsIndex &gt;= <span class="hljs-number">0x40</span>)</code></pre><p>From the disassembled code we can find that the expansion occurs when the passed-in
slot &gt;= 0x40. This confirmed our guess.
But since VLD will enter infinite recursion when it sees a TLS slot &gt;= 0x40,
why the stack overflow is never observed before?</p>
<p>This question has puzzled me for quite some time: the expansion is already done
in <code>TlsAlloc</code> for all threads, why memory allocation is still needed?
Until I notice that the expansion is only applied to a Thread Environment Block, (TEB, where <code>fs:[18h]</code> points to)
which means the expansion only affect the current thread.
All other threads remain intact.</p>
<h2 id="reproduce">Reproduce</h2>
<p>After above analysis, we can try to reproduce the infinite recursion so that we can prove the
conclusion is correct.</p>
<p>To increase TLS slot number, simply calling <code>TlsAlloc</code> in a loop will do the trick.</p>
<p>Another step required to reproduce is to make sure VLD gets assigned with a TLS slot &gt;= 64.
To do this, first increase TLS slot number, then load and enable VLD dynamically using <code>LoadLibrary</code> &amp; <code>GetProcAddress</code>.
After VLD is enabled, allocate memory in a new thread.</p>
<p><em>Minimum reproduce code sample</em></p>
<pre class="hljs"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">wchar_t</span> *argv[])</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x40</span>; ++i)
    TlsAlloc();

  HMODULE h_vld = LoadLibraryA(<span class="hljs-string">"vld.dll"</span>);
  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*<span class="hljs-keyword">vld_enable_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
  <span class="hljs-keyword">auto</span> vld_enable = (<span class="hljs-keyword">vld_enable_t</span>)::GetProcAddress(h_vld, <span class="hljs-string">"VLDGlobalEnable"</span>);
  vld_enable();
  <span class="hljs-built_in">std</span>::thread([]() {<span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(); }).join();
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre><p>Use above code we can make a program crash of stack overflow, with call stack almost the same as what I get
from our product crash dump. (Except for the first several lines which intializes CLR)
Our theory about VLD and TLS expansion is correct.</p>
<h2 id="conclusion">Conclusion</h2>
<p>How to explain why the crash is never met before?</p>
<p>VLD is linked to several DLLs of our product, and is statically initialized in these DLLs.
The DLLs are loaded dynamically at runtime when they are used, or never if they are not touched at runtime.
Maybe some recent change removed VLD from one of the DLLs which is always loaded before TLS allocation count
reaches 0x40, so sometimes when VLD is loaded, there are chances that more than 0x40 TLS slots allocated already.
That&#39;s why VLD gets assigned with TLS slot &gt;= 0x40.</p>
<p>Also we used lots of COM (both STA/MTA) in our product, threads and memory allocation are not rare.</p>
<p>When these 2 conditions are met, infinite recursion happens.</p>
<h2 id="references">References</h2>
<p>Thanks to Ken Johnson, his post of <a href="http://www.nynaeve.net/?p=181">Thread Local Storage, part 2: Explicit TLS</a> shed light
when I am wondering why this issue still happens when TLS expansion is checked inside each API.</p>
<p>I submit an bug for VLD of <a href="https://vld.codeplex.com/workitem/10590">this issue</a>.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>Thanks to my smart &amp; beautiful scientist girlfriend Z for her patience and time to review
this post and give insightful comments.</p>

                </div></div><hr><a href=/ class=left>Home</a> <a href=# class=right>Top</a></article><style>body{margin:1em auto;max-width:40em;padding:0 .62em;font:1.2em/1.62em sans-serif}h1,h2,h3{line-height:1.2em}@media print{body{max-width:none}}a{text-decoration:none}article{margin:auto;font-size:14px;padding:3px 1em}.metadata{color:rgba(0,0,0,.54)}hr{display:block;height:1px;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}.left{float:left}.right{float:right}</style><link rel=stylesheet href=/github-markdown.css><link rel=stylesheet href=/zenburn.css><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-42274645-1","auto"),ga("send","pageview")</script></body></html>