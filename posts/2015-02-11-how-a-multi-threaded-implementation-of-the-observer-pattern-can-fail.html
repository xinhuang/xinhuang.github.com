<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1"><title>How A Multi-Threaded Implementation of The Observer Pattern Can Fail</title></head><body><article id=top class=markdown-body><div><div><h1>How A Multi-Threaded Implementation of The Observer Pattern Can Fail</h1><div class=metadata>2015-02-11</div><hr>
                <h2 id="overview">Overview</h2>
<p>In an implementation of the Observer Pattern, usually there are two ways for an
 observer to de-register itself during destruction:</p>
<ol>
<li>De-register in <code>Observer</code> destructor</li>
<li>Use <code>std::weak_ptr</code> in <code>Observable</code></li>
</ol>
<p>For option 1, there will be a race condition if de-registering happens in the
 destructor of the base observer class, because the destructor of
 <code>AbstractObserver</code> is called after <code>ConcreteObserver</code>. If an event is triggered
 between the invocation of concrete destructor and abstract destructor, the
 observer will be in a partial state.</p>
<p>This misbehavior cannot be fixed as long as the concrete class inherits from
 <code>AbstractObserver</code> class, because <code>AbstractObserver</code> is always constructed
 first, and destroyed last.</p>
<p>To avoid such a problem, either use a combination of <code>std::shared_ptr</code> and
 <code>std::weak_ptr</code>, or use <a href="http://www.boost.org/doc/libs/1_57_0/doc/html/signals2.html">Boost.Signals2</a> instead of reinventing the wheel.</p>
<h2 id="the-gof-observer-pattern-">The <a href="http://en.wikipedia.org/wiki/Observer_pattern">GoF Observer Pattern</a></h2>
<pre class="hljs"><code class="C++"><span class="hljs-keyword">class</span> IObservable {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~IObservable() {}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(IObserver* observer)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(IObserver* observer)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> IObserver {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~IObserver() {}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};</code></pre><h2 id="what-happens-when-an-observer-is-going-to-be-destroyed-">What happens when an observer is going to be destroyed?</h2>
<p>Before an observer is destroyed, it has to be removed from the observers list.
 Explicit removal of the observer before each destruction is too much work
 and duplicate code, it is convenient, therefore, to automate observer
 un-registration.</p>
<p>Here is our new <code>AbstractObservable</code>/<code>AbstractObserver</code> with automatic
 un-registration in destructor:</p>
<pre class="hljs"><code class="C++"><span class="hljs-keyword">class</span> AbstractObservable : <span class="hljs-keyword">public</span> IObservable {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~AbstractObservable() {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(AbstractObserver* observer)</span> </span>{
        observers.insert(observer);
        observer.setObservable(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AbstractObserver* observer)</span> </span>{
        observers.erase(observer);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; o : observers) {
            o-&gt;notify();
        }
    }

<span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;AbstractObserver*&gt; observers;
};

<span class="hljs-keyword">class</span> AbstractObserver : <span class="hljs-keyword">public</span> IObserver {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~AbstractObserver() { observable.remove(<span class="hljs-keyword">this</span>); }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setObservable</span><span class="hljs-params">(AbstractObservable* observable)</span> </span>{ <span class="hljs-keyword">this</span>-&gt;observable = observable; }

<span class="hljs-keyword">private</span>:
    AbstractObservable* observable;
};</code></pre><h2 id="but-what-will-happen-in-a-multi-threaded-environment-">But what will happen in a multi-threaded environment?</h2>
<p>In a multi-threaded environment a race condition can happen when the
 observer list is updated. Simple problem! Only need a lock:</p>
<pre class="hljs"><code class="C++"><span class="hljs-comment">// same for add and notify</span>
<span class="hljs-keyword">void</span> AbstractObservable::remove(AbstractObserver* observer) {
    <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; lock(mutex);
    observers.erase(observer);
}</code></pre><p>But think again about the runtime behavior. Is it really thread-safe?</p>
<p>Here is the normal destruction order of an observer:</p>
<ol>
<li><p><code>ConcreteObserver::~ConcreteObserver()</code></p>
</li>
<li><p><code>AbstractObserver::~AbstractObserver()</code></p>
</li>
</ol>
<p>What if, during the destruction of an observer, an event is fired?
 Now the following invocation sequence can occur:</p>
<ol>
<li><p><code>ConcreteObserver::~ConcreteObserver()</code></p>
</li>
<li><p><code>ConcreteObservable::notify()</code></p>
</li>
<li><p><code>ConcreteObserver::onNotify()</code></p>
</li>
<li><p><code>AbstractObserver::~AbstractObserver()</code></p>
</li>
</ol>
<p>Previously, to ensure the exclusive call to <code>add</code>, <code>remove</code> and <code>notify</code> functions
 of <code>AbstractObservable</code>, we use a lock. But the destructor of <code>ConcreteObserver</code>
 and <code>notify</code> functions of <code>AbstractObservable</code> are not exclusive. Hence when
 an event is triggered while the destructor <code>ConcreteObserver</code> is executing, the
 <code>onNotify</code> of the <code>ConcreteObserver</code> will be called on a (partially) destroyed
 object. This is why the race condition can happen.</p>
<h2 id="is-there-a-better-way-">Is there a better way?</h2>
<p>To avoid this problem, there are several alternatives:</p>
<ol>
<li><p>Explicitly remove observer in the most derived destructor. This could be error
prone, and the problem can still occur because you can always inherit from
<code>ConcreteObserver</code>.</p>
</li>
<li><p>Explicitly un-registe observer before its destructor is called. This requires
a customized deleter to call an unregister function if you use <code>std::shared_ptr</code>,
or having to be careful if the observer&#39;s life span is managed manually - with a
lot of repeated code to remove observers to boot.</p>
<p> For example:</p>
</li>
</ol>
<pre class="hljs"><code class="C++"><span class="hljs-comment">// manually unregister observer from observable</span>
{
  ConcreteObserver scopedObserver;
  observable.add(scopedObserver);
  <span class="hljs-comment">// ...</span>
  observable.remove(scopedObserver);
} <span class="hljs-comment">// scopredObserver is destroyed here</span>

<span class="hljs-comment">// manually unregister observer from observable using std::shared_ptr</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Observer&gt; observer(<span class="hljs-keyword">new</span> ConcreteObserver(),
                                   [&amp;](Observer* o) {
                                     observable.remove(o);
                                   });
observable.add(observer);</code></pre><ol>
<li><p>Use a combination of <code>std::shared_ptr</code> and <code>std::weak_ptr</code>. In this way the
race condition can be avoided completely.</p>
<p> For example:</p>
</li>
</ol>
<pre class="hljs"><code class="C++"><span class="hljs-keyword">class</span> IObserver {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> ~IObserver() {}
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> Observable {
  <span class="hljs-built_in">std</span>::mutex mutex;
  <span class="hljs-comment">// of course the std::vector can be replace by a concurrent container</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::weak_ptr&lt;IObserver&gt;&gt; observers;  

<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> ~Observable() {}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;IObserver&gt;&amp; o)</span> </span>{
    <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; lock(mutex);
    observers.emplace_back(o);
  }
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;IObserver&gt;&amp; o)</span> </span>{
    <span class="hljs-comment">/* here we do nothing, invalid observers will be removed in notify */</span>
  }
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; lock(mutex);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; o : observers) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> p = o.lock())
        p-&gt;onNotify();
    }
    remove_invalid_observer();
  }

<span class="hljs-keyword">private</span>:
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove_invalid_observer</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> first_invalid = <span class="hljs-built_in">std</span>::remove_if(<span class="hljs-built_in">std</span>::begin(observers),
                                        <span class="hljs-built_in">std</span>::end(observers),
                                        [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::weak_ptr&lt;IObserver&gt;&amp; o) {
                                          <span class="hljs-keyword">return</span> o.expired();
                                        });
    observers.erase(last_valid, <span class="hljs-built_in">std</span>::end(observers));
  }
};</code></pre><ol>
<li>Don&#39;t reinvent the wheel, use <a href="http://www.boost.org/doc/libs/1_57_0/doc/html/signals2.html">Boost.Signals2</a> instead.
<a href="http://www.boost.org/doc/libs/1_57_0/doc/html/signals2/thread-safety.html#idp430084640">&quot;It can be used safely in a multi-threaded environment.&quot;</a></li>
</ol>
<h2 id="so-what-is-the-real-problem-">So what is the real problem?</h2>
<p>The moral of this tale is that inheritance isn&#39;t always as harmless as it might
 seem, notwithstanding the great benefit of code re-usability. In a
 multi-threaded environment, inheritance can easily break the constraints while
 giving the user an illusion that the original constraints are naturally
 &quot;inherited&quot;. <strong>Code and functions can be inherited, but the situation is not
 the same for concurrent constraints.</strong></p>
<hr>
<p> <em>Many thanks to David Wales who helped review this post.</em></p>

                </div></div><hr><a href=/ class=left>Home</a> <a href=# class=right>Top</a></article><style>body{margin:1em auto;max-width:40em;padding:0 .62em;font:1.2em/1.62em sans-serif;background-color:#f0efd1}h1,h2,h3{line-height:1.2em}@media print{body{max-width:none}}a{text-decoration:none}article{margin:auto;font-size:14px;padding:3px 1em}.metadata{color:rgba(0,0,0,.54)}hr{display:block;height:1px;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}.left{float:left}.right{float:right}</style><link rel=stylesheet href=/github-markdown.css><link rel=stylesheet href=/zenburn.css><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-42274645-1","auto"),ga("send","pageview")</script></body></html>