<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1"><title>Extending GoogleTest</title></head><body><article id=top class=markdown-body><div><div><h1>Extending GoogleTest</h1><div class=metadata>2013-11-16</div>
                <p>Maybe you are tired of the syntax <a href="https://code.google.com/p/googletest/">googletest</a> has chosen, so you deside to invent you own unit test DSL. But re-implementing the whole execution &amp; report part of a unit test framework would be too much, esp. you want to ship your &quot;product&quot; somewhere.</p>
<p>Then the option left would be extending an existing one, and <a href="https://code.google.com/p/googletest/">googletest</a> is a good candidate.</p>
<h2 id="behind-the-curtain">Behind the curtain</h2>
<h3 id="a-basic-version">A basic version</h3>
<p>First of all, before extending googletest, we need to know what&#39;s behind the curtain.<br>A typical unit test would be:</p>
<pre class="hljs"><code class="C++"><span class="hljs-keyword">class</span> Fixture : <span class="hljs-keyword">public</span> ::testing::Test {
};

TEST_F(Fixture, GIVEN_1_THEN_add_1_SHOULD_return_0) {
    ASSERT_EQ(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>);
}</code></pre><p><em>Sorry for my bad math.</em></p>
<p>In above code snippet, googletest does 3 things:  </p>
<ol>
<li>Create a class inherited from <code>Fixture</code>.  </li>
<li>Override a method in <code>Fixture</code>.  </li>
<li>Execute some code to register the newly created class somewhere.</li>
</ol>
<p>All the magic is done within macro <code>TEST_F</code>.<br>If you are familiar with macro, it won&#39;t take a minute to figure out <code>TEST_F</code> actually expand to:  </p>
<pre class="hljs"><code class="C++"><span class="hljs-comment">/* --------- Expand start -----------&gt; */</span>
<span class="hljs-keyword">class</span> prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethodCalledWhenExecuteTest</span><span class="hljs-params">()</span></span>;
};
<span class="hljs-keyword">void</span> prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix::SomeMethodCalledWhenExecuteTest()
<span class="hljs-comment">/* &lt;-------- Expand end --------------&gt; */</span>
{
    ASSERT_EQ(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>);
}</code></pre><p>Now, we&#39;ve done No. 1 and No. 2. But what about No. 3? How to execute some code outside the <code>main</code> function?<br>The answer is simple: <em>Use global variables</em>, and perform registration in the construction of the variable:</p>
<pre class="hljs"><code class="C++"><span class="hljs-comment">/* --------- Expand start -----------&gt; */</span>
<span class="hljs-keyword">class</span> prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethodCalledWhenExecuteTest</span><span class="hljs-params">()</span></span>;
};
prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix instance_GIVEN_1_THEN_add_1_SHOULD_return_0;
<span class="hljs-keyword">void</span> prefixGIVEN_1_THEN_add_1_SHOULD_return_0postfix::SomeMethodCalledWhenExecuteTest()
<span class="hljs-comment">/* &lt;-------- Expand end --------------&gt; */</span></code></pre><h3 id="the-googletest-version">The googletest version</h3>
<p>This only demonstrate the basic idea of how <code>TEST_F</code> works. Knowing this, we can find out how to extend googletest.</p>
<p>Watching the macro _TEST_F_, it does a bit more than our basic version:</p>
<pre class="hljs"><code class="C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)         \
class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class { \
public:                                                                         \
    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}                      \
private:                                                                        \
    virtual void TestBody();                                                    \
    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;       \
    GTEST_DISALLOW_COPY_AND_ASSIGN_(                                            \
        GTEST_TEST_CLASS_NAME_(test_case_name, test_name));                     \
};                                                                              \</span></code></pre><p>Above code defines the test class inherites from test fixture.</p>
<p>First, create the global variable:</p>
<pre class="hljs"><code class="C++">::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)   \
  ::test_info_ =                                                               \</code></pre><p>Then, initialize the global variable:</p>
<pre class="hljs"><code class="C++">::testing::internal::MakeAndRegisterTestInfo(                                  \
    #test_case_name, #test_name, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>,                                   \
    (parent_id),                                                               \
    parent_class::SetUpTestCase,                                               \
    parent_class::TearDownTestCase,                                            \
    <span class="hljs-keyword">new</span> ::testing::internal::TestFactoryImpl&lt;                                  \
        GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);                   \</code></pre><p>Registration is performed inside <code>::testing::internal::MakeAndRegisterTestInfo</code>.</p>
<p>At last, is the <em>TestBody</em> stub, which connects real test code:</p>
<pre class="hljs"><code class="C++">void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()</code></pre><h4 id="inside-registertestinfo">Inside RegisterTestInfo</h4>
<p>Let&#39;s take a closer look at what happened inside <code>MakeAndRegisterTestInfo</code>:</p>
<pre class="hljs"><code class="C++"><span class="hljs-function">TestInfo* <span class="hljs-title">MakeAndRegisterTestInfo</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* test_case_name,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* type_param,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* value_param,
    TypeId fixture_class_id,
    SetUpTestCaseFunc set_up_tc,                <span class="hljs-comment">// Set up for the first of fixture class.</span>
    TearDownTestCaseFunc tear_down_tc,          <span class="hljs-comment">// Tear down after execute of all tests in a fixture.</span>
    TestFactoryBase* factory)</span></span>;                  <span class="hljs-comment">// Factory creates the test class instances.</span></code></pre><p>First 2 parameters are easy to tell from their name, last 3 are also not difficult.<br><code>type_param</code> and <code>value_param</code> are both passed as <code>NULL</code> in <code>TEST_F</code> macro, so we can ignore them until we really got some problem.</p>
<p>Then, what is <code>fixture_class_id</code>? If we are using a different model from googletest, what should the value be?<br>By searching the code, we can easily find out the type id is used to tell a test going to run whether is the first one under a fixture. If it is, then the <code>tear_down_tc</code> of previous fixture and <code>set_up_tc</code> of the fixture should be called.<br>So if you don&#39;t care about it, ignore it.</p>
<h2 id="register-our-test">Register our test</h2>
<p>After all the work, it is clear that all the macro makes googletest &quot;user interface&quot;. If we want to connect our unit test DSL with googletest, register the test via <code>MakeAndRegisterTestInfo</code>.</p>
<p>Now we are ready to let our test sneaks in. Here is the complete code: (C++ 11)</p>
<pre class="hljs"><code class="C++">class NoFixture {};
void nop() {}

class FunctionTest : public ::testing::Test {
public:
    FunctionTest(function&lt;void()&gt; function)
        : function_(function)
    {}
private:
    const function&lt;void()&gt; function_;
    void TestBody() override { function_(); }
};

class TestFactory : public ::testing::internal::TestFactoryBase {
public:
    TestFactory(function&lt;void()&gt; function)
        : function_(function) {}
    ::testing::Test* CreateTest() override {
        return new FunctionTest(function_);
    }
private:
    const function&lt;void()&gt; function_;
};

void Register(const string&amp; test_name, const string&amp; case_name, function&lt;void()&gt; test) {
    static auto fixture_class_id = ::testing::internal::GetTypeId&lt;NoFixture&gt;();
    ::testing::internal::MakeAndRegisterTestInfo(test_name.c_str(), case_name.c_str(), nullptr, nullptr,
        fixture_class_id, nop, nop, new TestFactory(test));
}</code></pre>
                </div></div><hr><a href=/ class=left>Home</a> <a href=# class=right>Top</a></article><style>body{margin:1em auto;max-width:40em;padding:0 .62em;font:1.2em/1.62em sans-serif}h1,h2,h3{line-height:1.2em}@media print{body{max-width:none}}a{text-decoration:none}article{margin:auto;font-size:14px;padding:3px 1em}.metadata{color:rgba(0,0,0,.54)}hr{display:block;height:1px;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}.left{float:left}.right{float:right}</style><link rel=stylesheet href=/github-markdown.css><link rel=stylesheet href=/zenburn.css><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-42274645-1","auto"),ga("send","pageview")</script></body></html>