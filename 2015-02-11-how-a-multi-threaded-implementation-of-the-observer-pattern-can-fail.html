<!doctype html><html ng-app=xinhuangGithubCom ng-strict-di><head><meta charset=utf-8><title>How A Multi-Threaded Implementation of The Observer Pattern Can Fail</title><meta name=description content=""><meta name=viewport content="width=device-width"><!-- Place favicon.ico and apple-touch-icon.png in the root directory --><link rel=stylesheet href=styles/vendor-bfbf54ee58.css><link rel=stylesheet href=styles/app-d5a71a58a1.css><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-42274645-1', 'auto');
      ga('send', 'pageview');</script></head><body><!--[if lt IE 10]>
      <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]--><article id=top class=anchor><div layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70><h1 class=md-h1>How A Multi-Threaded Implementation of The Observer Pattern Can Fail</h1><div class=entry-meta>2015-02-11</div><textarea>
              <marked>
                  
## Overview

In an implementation of the Observer Pattern, usually there are two ways for an
 observer to de-register itself during destruction:

1. De-register in `Observer` destructor
2. Use `std::weak_ptr` in `Observable`

For option 1, there will be a race condition if de-registering happens in the
 destructor of the base observer class, because the destructor of
 `AbstractObserver` is called after `ConcreteObserver`. If an event is triggered
 between the invocation of concrete destructor and abstract destructor, the
 observer will be in a partial state.

This misbehavior cannot be fixed as long as the concrete class inherits from
 `AbstractObserver` class, because `AbstractObserver` is always constructed
 first, and destroyed last.

To avoid such a problem, either use a combination of `std::shared_ptr` and
 `std::weak_ptr`, or use [Boost.Signals2] instead of reinventing the wheel.

## The [GoF Observer Pattern]

```
class IObservable {
public:
	virtual ~IObservable() {}
	virtual void add(IObserver* observer) = 0;
	virtual void remove(IObserver* observer) = 0;
	virtual void notify() = 0;
};

class IObserver {
public:
	virtual ~IObserver() {}
	virtual void onNotify() = 0;
};
```

## What happens when an observer is going to be destroyed?

Before an observer is destroyed, it has to be removed from the observers list.
 Explicit removal of the observer before each destruction is too much work
 and duplicate code, it is convenient, therefore, to automate observer
 un-registration.

Here is our new `AbstractObservable`/`AbstractObserver` with automatic
 un-registration in destructor:

```
class AbstractObservable : public IObservable {
public:
	virtual ~AbstractObservable() {}
	void add(AbstractObserver* observer) {
		observers.insert(observer);
		observer.setObservable(this);
	}
	void remove(AbstractObserver* observer) {
		observers.erase(observer);
	}
	void notify() {
		for (auto&amp; o : observers) {
			o-&gt;notify();
		}
	}

private:
  std::unordered_set&lt;AbstractObserver*&gt; observers;
};

class AbstractObserver : public IObserver {
public:
	virtual ~AbstractObserver() { observable.remove(this); }
	virtual void notify() = 0;
	void setObservable(AbstractObservable* observable) { this-&gt;observable = observable; }

private:
	AbstractObservable* observable;
};
```

## But what will happen in a multi-threaded environment?

In a multi-threaded environment a race condition can happen when the
 observer list is updated. Simple problem! Only need a lock:

```
// same for add and notify
void AbstractObservable::remove(AbstractObserver* observer) {
	std::lock_guard&lt;std::mutex&gt; lock(mutex);
	observers.erase(observer);
}
```

But think again about the runtime behavior. Is it really thread-safe?

Here is the normal destruction order of an observer:

1. `ConcreteObserver::~ConcreteObserver()`

2. `AbstractObserver::~AbstractObserver()`

What if, during the destruction of an observer, an event is fired?
 Now the following invocation sequence can occur:

1. `ConcreteObserver::~ConcreteObserver()`

2. `ConcreteObservable::notify()`

3. `ConcreteObserver::onNotify()`

4. `AbstractObserver::~AbstractObserver()`

Previously, to ensure the exclusive call to `add`, `remove` and `notify` functions
 of `AbstractObservable`, we use a lock. But the destructor of `ConcreteObserver`
 and `notify` functions of `AbstractObservable` are not exclusive. Hence when
 an event is triggered while the destructor `ConcreteObserver` is executing, the
 `onNotify` of the `ConcreteObserver` will be called on a (partially) destroyed
 object. This is why the race condition can happen.

## Is there a better way?

To avoid this problem, there are several alternatives:

1. Explicitly remove observer in the most derived destructor. This could be error
 prone, and the problem can still occur because you can always inherit from
 `ConcreteObserver`.

2. Explicitly un-registe observer before its destructor is called. This requires
 a customized deleter to call an unregister function if you use `std::shared_ptr`,
 or having to be careful if the observer&#039;s life span is managed manually - with a
 lot of repeated code to remove observers to boot.

    For example:

        // manually unregister observer from observable
        {
          ConcreteObserver scopedObserver;
          observable.add(scopedObserver);
          // ...
          observable.remove(scopedObserver);
        } // scopredObserver is destroyed here

        // manually unregister observer from observable using std::shared_ptr
        std::shared_ptr&lt;Observer&gt; observer(new ConcreteObserver(),
                                           [&amp;](Observer* o) {
                                             observable.remove(o);
                                           });
        observable.add(observer);

3. Use a combination of `std::shared_ptr` and `std::weak_ptr`. In this way the
 race condition can be avoided completely.

    For example:

        class IObserver {
        public:
          virtual ~IObserver() {}
          virtual void onNotify() = 0;
        };

        class Observable {
          std::mutex mutex;
          // of course the std::vector can be replace by a concurrent container
          std::vector&lt;std::weak_ptr&lt;IObserver&gt;&gt; observers;  

        public:
          virtual ~Observable() {}
          void add(const std::shared_ptr&lt;IObserver&gt;&amp; o) {
            std::lock_guard&lt;std::mutex&gt; lock(mutex);
            observers.emplace_back(o);
          }
          void remove(const std::shared_ptr&lt;IObserver&gt;&amp; o) {
            /* here we do nothing, invalid observers will be removed in notify */
          }
          void notify() {
            std::lock_guard&lt;std::mutex&gt; lock(mutex);
            for (auto&amp; o : observers) {
              if (auto p = o.lock())
                p-&gt;onNotify();
            }
            remove_invalid_observer();
          }

        private:
          void remove_invalid_observer() {
            auto first_invalid = std::remove_if(std::begin(observers),
                                                std::end(observers),
                                                [](const std::weak_ptr&lt;IObserver&gt;&amp; o) {
                                                  return o.expired();
                                                });
            observers.erase(last_valid, std::end(observers));
          }
        };

4. Don&#039;t reinvent the wheel, use [Boost.Signals2] instead.
 [&quot;It can be used safely in a multi-threaded environment.&quot;]

## So what is the real problem?

The moral of this tale is that inheritance isn&#039;t always as harmless as it might
 seem, notwithstanding the great benefit of code re-usability. In a
 multi-threaded environment, inheritance can easily break the constraints while
 giving the user an illusion that the original constraints are naturally
 &quot;inherited&quot;. **Code and functions can be inherited, but the situation is not
 the same for concurrent constraints.**

 ---

 _Many thanks to David Wales who helped review this post._

[GoF Observer Pattern]: http://en.wikipedia.org/wiki/Observer_pattern
[Boost.Signals2]:http://www.boost.org/doc/libs/1_57_0/doc/html/signals2.html
[&quot;It can be used safely in a multi-threaded environment.&quot;]:http://www.boost.org/doc/libs/1_57_0/doc/html/signals2/thread-safety.html#idp430084640

              </marked>
          </textarea></div></div><md-divider></md-divider><div class=footer layout=row><div flex=30 flex-xs=0 flex-sm=15></div><div flex=40 flex-xs=100 flex-sm=70 layout=row><a href=/ >Home</a><div flex></div><a href="" ng-click=blog.scrollToTop()>Top</a></div></div></article><script src=scripts/vendor-b1387507a1.js></script><script src=scripts/app-1e997bf866.js></script></body></html>